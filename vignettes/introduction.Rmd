---
title: "Programmable Non-Standard Evaluation"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: false
        css: styles.css

vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, comment=NA)
library(recsub)
```

```{r child='./rmdhunks/intro.Rmd'}
```

## Other Considerations

One drawback of the `eval`/`bquote`/`.()` pattern is that the actual objects
inside `.()` are placed on the call stack.  This is not an issue with symbols,
but can be bothersome with data or functions.  For example, in:

```{r, eval=FALSE}
my_fun_inner <- function(x) {
  # ... bunch of code
  stop("end")
}
my_fun_outer <- function(x) {
  eval(bquote(.(my_fun)(.(x))), parent.frame())
}
my_fun_outer(mtcars)
traceback()
```

The entire function definition as well as the data frame will be displayed by
the traceback, which makes it difficult to see what is happening.  A simple
work-around is to use:

```{r, eval=FALSE}
sapply(.traceback(), head, 1)
```

This will show only the first line of each deparsed call.  Similarly:

```{r, eval=FALSE}
sapply(sys.calls(), head, 1)
```
