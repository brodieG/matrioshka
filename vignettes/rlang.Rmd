---
title: "Comparison of Programmable NSE Frameworks"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{vetr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, comment=NA)
library(dplyr)
library(recsub)
```

## Overview

We want to re-implement `summarize_by` function introduced in the [userR 2017
Tidy Eval][1] session:

```{r}
summarise_by <- function(df, group, var) {
  group <- enquo(group)
  var <- enquo(var)
  df %>%
    group_by(!! group) %>%
    summarise(avg = mean(!! var))
}
summarise_by(starwars, species, height) %>% head(2)
```

With `recsub` we would use:

```{r}
summarise_by_r <- function(df, group, var) {
  group <- substitute(group)
  var <- substitute(var)
  expr <- recsub(
    bquote(
      .(df) %>%
      group_by(.(group)) %>%
      summarise(avg = mean(.(var)))
    ),
    df, parent.frame()
  )
  eval(expr, parent.frame())
}
summarise_by_r(starwars, species, height) %>% head(2)
```

While this looks a lot more complicated, keep in mind we just added programmable
NSE to something that has no idea `recsub` even exists.  `dplyr` implements its
own NSE with internal logic to handle the quo/dequo business.

With one advantage that we can do things like:

```{r}
my.var <- quote(species)
summarise_by_r(starwars, my.var, height) %>% head(2)
summarise_by(starwars, my.var, height) %>% head(2)
```

This would be even simpler if `group_by` and `summarise` had been built with
`recsub` to begin with:

```{r}
group_by_r <- function(.data, ..., add=FALSE) {
  group.call <- recsub(sys.call(), .data, parent.frame())
  group.call[[1]] <- quote(group_by)
  eval(group.call, parent.frame())
}
summarise_r <- function(.data, ..., add=FALSE) {
  summarise.call <- recsub(sys.call(), .data, parent.frame())
  summarise.call[[1]] <- quote(summarise)
  eval(summarise.call, parent.frame())
}
summarise_by_r2 <- function(df, group, var) {
  group <- substitute(group)
  var <- substitute(var)
  eval(
    bquote(.(df) %>% group_by_r(.(group)) %>% summarise_r(avg=mean(.(var)))),
    parent.frame()
  )
}
summarise_by_r2(starwars, species, height) %>% head(2)
summarise_by_r2(starwars, my.var, height) %>% head(2)

local({
  my.var <- quote(skin_color)
  summarise_by_r2(starwars, my.var, height) %>% head(2)
})
my.var <- quote(skin_color)
summarise_by_r2(starwars, my.var, height) %>% head(2)
```


```{r}
dot_list <- function(x, pre="V") {
  dots <- tail(as.list(x), -1L)
  for(i in seq_along(dots))
    names(dots)[i] <- if(is.language(dots[[i]])) deparse(dots[[i]])[[1]]
      else sprintf("%s%d", pre, i)
  dots
}
grp_by <- function(.data, ..., .ENV=parent.frame()) {
  grp.sub <- recsub(substitute(list(...)), .data, .ENV)
  structure(.data, .GRP=dot_list(grp.sub, "G"))
}
summr <- function(.data, ..., .ENV=parent.frame()) {
  exps.sub <- recsub(substitute(list(...)), .data, .ENV)

  # compute groups and split data

  has.grp <- !is.null(attr(.data, ".GRP"))
  .data <- as.data.frame(.data)
  grps <- if(!has.grp) list(rep_len(1, nrow(.data))) else attr(.data, ".GRP")
  splits <- lapply(grps, eval, .data, parent.frame())
  dat.split <- split(.data, splits, drop=TRUE)
  grp.split <- if(has.grp) lapply(splits, split, splits, drop=TRUE)

  # compute the aggregations

  res.list <- lapply(
    dot_list(exps.sub),
    function(exp) lapply(dat.split, eval, expr=exp, enclos=parent.frame())
  )
  # Find max number of rows in each group, and recycle to that

  lens <- do.call(pmax, lapply(res.list, lengths, integer(length(splits))))
  res.list.r <- lapply(
    c(grp.split, res.list), function(x) unname(unlist(Map(rep_len, x, lens)))
  )
  as.data.frame(res.list.r)
}
`[.super_df` <- function(x, i, j, by, drop=FALSE, .ENV=parent.frame()) {

  j.sub <- substitute(j)
  by.sub <- substitute(by)
  eval(bquote(.(summr)(.(grp_by)(.(x), .(by.sub)), .(j.sub))), enclos=.ENV)
}
as.super_df <- function(x) {
  class(x) <- c("super_df", class(x))
  x
}
sw <- as.super_df(starwars)
sw[, list(mean(height), max(mass)), list(species, hair_color)]
sw[, mean(height), species]

starwars %>% group_by(species, hair_color) %>% summarize(mean(height))

starwars %>%
  grp_by(species, hair_color) %>%

  summr(median(height), mean(mass))

iris %>% grp_by(Species) %>% summr(sum(Sepal.Length), mean(Sepal.Length))

local({
  my.grp <- quote(Species)
  my.val <- quote(Sepal.Width)
  iris %>% grp_by(my.grp) %>% summr(sum(my.val), mean(my.val))
})

my_sum <- function(.data, group, var) {
  eval(
    bquote(
      .(.data) %>%
        grp_by(.(substitute(group))) %>%
        summr(sum(.(substitute(var))), mean(.(substitute(var))))
    ),
    parent.frame()
  )
}
my_sum(iris, Species, Petal.Length)

```{r}
ll <- base::list
tf <- function(data, ...) {
  expr <- substitute(ll(...))
  vals <- eval(expr, data, parent.frame())
  vals
}
```


## References

[1]: https://schd.ws/hosted_files/user2017/43/tidyeval-user.pdf
[2]: https://www.r-project.org/dsc/2017/slides/tidyeval-hygienic-fexprs.pdf
