---
title: "Comparison of Programmable NSE Frameworks"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{vetr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, comment=NA)
library(dplyr)
library(recsub)
```

## Overview

We want to re-implement `summarize_by` function introduced in the [userR 2017
Tidy Eval][1] session:

```{r}
summarise_by <- function(df, group, var) {
  group <- enquo(group)
  var <- enquo(var)
  df %>%
    group_by(!! group) %>%
    summarise(avg = mean(!! var))
}
summarise_by(starwars, species, height) %>% head(2)
```

With `recsub` we would use:

```{r}
summarise_by_r <- function(df, group, var) {
  group <- substitute(group)
  var <- substitute(var)
  expr <- recsub(
    bquote(
      .(df) %>%
      group_by(.(group)) %>%
      summarise(avg = mean(.(var)))
    ),
    df, parent.frame()
  )
  eval(expr, parent.frame())
}
summarise_by_r(starwars, species, height) %>% head(2)
```

While this looks a lot more complicated, keep in mind we just added programmable
NSE to something that has no idea `recsub` even exists.  `dplyr` implements its
own NSE with internal logic to handle the quo/dequo business.

With one advantage that we can do things like:

```{r}
my.var <- quote(species)
summarise_by_r(starwars, my.var, height) %>% head(2)
summarise_by(starwars, my.var, height) %>% head(2)
```

This would be even simpler if `group_by` and `summarise` had been built with
`recsub` to begin with:

```{r}
group_by_r <- function(.data, ..., add=FALSE) {
  group.call <- recsub(sys.call(), .data, parent.frame())
  group.call[[1]] <- quote(group_by)
  eval(group.call, parent.frame())
}
summarise_r <- function(.data, ..., add=FALSE) {
  summarise.call <- recsub(sys.call(), .data, parent.frame())
  summarise.call[[1]] <- quote(summarise)
  eval(summarise.call, parent.frame())
}
summarise_by_r2 <- function(df, group, var) {
  group <- substitute(group)
  var <- substitute(var)
  eval(
    bquote(.(df) %>% group_by_r(.(group)) %>% summarise_r(avg=mean(.(var)))),
    parent.frame()
  )
}
summarise_by_r2(starwars, species, height) %>% head(2)
summarise_by_r2(starwars, my.var, height) %>% head(2)

local({
  my.var <- quote(skin_color)
  summarise_by_r2(starwars, my.var, height) %>% head(2)
})
my.var <- quote(skin_color)
summarise_by_r2(starwars, my.var, height) %>% head(2)
```


```{r}

clean_dots <- function(x) tail(as.list(x), -1L)
recycle <- function(x, n) {
  if(length(x) < n) x <- rep(x, ceil(n / length(x)))
  length(x) <- n
  x
}
group_names <- function(x) {
  names.clean <- clean_dots(x)
  group.res <- vector("list", length(names.clean))
  for(i in seq_along(names.clean)) group.res[[i]] <-
    if(is.symbol(names.clean[[i]])) as.character(names.clean[[i]])
    else sprintf("G%d", i)
  group.res
}

grp_by <- function(.data, ...) {
  grp.sub <- recsub(substitute(list(...)), .data, parent.frame())
  structure(.data, .GRP=grp.sub)
}
summr <- function(.data, ...) {
  exps.sub <- clean.dots(recsub(substitute(list(...)), .data, parent.frame()))
  grps <- attr(.data, ".GRP")
  splits <- eval(grps, .data, parent.frame())

  exps.names <- if(!is.null(names(exps.sub))) tail(names(exps.sub), -1L) else
    paste0("V", seq_along(exps.sub))

  dat.split <- split(.data, splits)
  res.list <- setNames(vector("list", length(exps.sub)), exps.names)

  # compute the aggregations

  res.list <- c(
    list(grp=names(dat.split)),
    setNames(
      lapply(
        exps.sub,
        function(exp) lapply(dat.split, eval, expr=exp, enclos=parent.frame())
      ),
      exps.names
  ) )
  # Determine how many rows in each group, and recycle

  grp.lens <- vapply(res.list, lengths, integer(length(splits)))

  for(exp.sub in exps.sub)
    for(i in seq_along(dat.split))
      res.list[[i]][[j]] <- eval(exp.sub, dat.split[[i]], parent.frame())

  do.call(rbind, lapply(res.list, do.call, what=cbind))
}
iris %>% grp_by(Species) %>% summr(sum(Sepal.Length), mean(Sepal.Length))
local({
  my.grp <- quote(Species)
  my.val <- quote(Sepal.Width)
  iris %>% grp_by(my.grp) %>% summr(sum(my.val), mean(my.val))
})

my_sum <- function(.data, group, var) {
  eval(
    bquote(
      .(.data) %>%
        grp_by(.(substitute(group))) %>%
        summr(sum(.(substitute(var))), mean(.(substitute(var))))
    ),
    parent.frame()
  )
}
my_sum(iris, Species, Petal.Length)

```


## References

[1]: https://schd.ws/hosted_files/user2017/43/tidyeval-user.pdf
[2]: https://www.r-project.org/dsc/2017/slides/tidyeval-hygienic-fexprs.pdf
