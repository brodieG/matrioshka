---
title: "Comparison of Programmable NSE Frameworks"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{vetr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, comment=NA)
library(recsub)
```

## `recsub` in Action

We will implement simplified versions of `dplyr` and `data.table` to illustrate
how one could use `recsub` to develop programmable NSE functions.  The
implementations will be limited in functionality, robustness, and speed, but
despite this we hope you will find them adequate for pedagogical purposes.

Our test data is derived from the `state` data that comes pre-loaded with R:

```{r}
head(state.data, 2)
```

## An Ersatz `dplyr`

The interface is as follows:

```{r, eval=FALSE}
group_r <- function(x, ...) {...}     # similar to dplyr::group_by
filter_r <- function(x, subset) {...} # similar to dplyr::filter
summarize_r <- function(x, ...) {...} # similar to dplyr::summarise
`%$%` <- function(x, y) {...}         # similar to the magrittr pipe
```

Most of the implementation is not directly related to NSE, but we will go over
`summarize_r` to highlight the NSE bits.  `summarize_r` is actually just a
forwarding function:

```{r dplyr_extra_0}
summarize_r <- function(x, ...)
  eval(bquote(.(summarize_r_l)(.(x), .(substitute(list(...))))), parent.frame())
```

This uses the `eval`/`bquote` pattern to forward the `NSE` arguments to the
function that does the actual work.  There is nothing `recsub` specific here.
Worth noting that we use `.()` to make sure the function and the data are
evaluated in the function environment and not the parent frame.  This is
important as this way we ensure the function is looked up with the
namespace/search path we expect.

Now the real work:

```{r dplyr_extra_1}
summarize_r_l <- function(x, els) {
  frm <- parent.frame()
  exps.sub <- recsub(substitute(els), x, frm)
  if(is.null(exps.sub)) x else {
    # compute groups and splits
    grps <- make_grps(x)
    splits <- lapply(grps, eval, x, frm)
    dat.split <- split(x, splits, drop=TRUE)
    grp.split <- if(!is.null(grps)) lapply(splits, split, splits, drop=TRUE)

    # aggregate
    res.list <- lapply(
      dot_list(exps.sub),       # see appendix for definition
      function(exp) lapply(dat.split, eval, expr=exp, enclos=frm)
    )
    # recycle to equal lengths and make data frame (see appendix)
    list_to_df(res.list, grp.split)
  }
}
```

The only `recsub` specific line is the second one.

```{r eval=FALSE}
  exps.sub <- recsub(substitute(els), x, frm)
```

`els` should be the language captured from the `...` argument.  We run `recub`
on that language with our data `x` and the parent frame, which by design is the
same parent frame a for `summarize_r`.  From this point forward we just need to
cleanup the language and evaluate in the right environments.



```{r dplyr_extra_2}

# -- Grouping ------------------------------------------------------------------

group_r <- function(x, ...)
  eval(bquote(.(group_r_l)(.(x), .(substitute(list(...))))), parent.frame())
group_r_l <- function(x, els) {
  exps.sub <- recsub(substitute(els), x, parent.frame())
  if(is.null(exps.sub)) x else {
    if(!is.call(exps.sub) || exps.sub[[1L]] != quote(list))
      exps.sub <- call("list", exps.sub)
    structure(x, .GRP=dot_list(exps.sub, "G"))
} }
# -- Filtering -----------------------------------------------------------------

filter_r <- function(x, subset) {
  sub.exp <- substitute(subset)
  sub.val <- evalr(sub.exp, envir=x, enclos=parent.frame())
  as.data.frame(
    if(!is.null(sub.val)) {
      as.data.frame(x)[
        if(is.numeric(sub.val)) sub.val else !is.na(sub.val) & sub.val,
      ]
    } else x
  )
}
# -- Pipe ----------------------------------------------------------------------

`%$%` <- function(x, y) {
  x.sub <- recsub(substitute(x), parent.frame())
  y.sub <- recsub(substitute(y), parent.frame())
  y.list <- if(!is.call(y.sub)) list(y.sub) else as.list(y.sub)
  eval(sub_dat(y.sub, x), parent.frame())
}
# -- Helper Funs ---------------------------------------------------------------

# Takes result of `substitute(list(...))` and returns a list of quoted language
# object with nice names.

dot_list <- function(x, pre="V") {
  if(!is.call(x) || x[[1L]] != quote(list)) x <- call("list", x)
  dots <- tail(as.list(x), -1L)

  if(is.null(names(dots))) names(dots) <- character(length(dots))
  for(i in seq_along(dots)[!nzchar(names(dots))])
    names(dots)[i] <- if(
      is.language(dots[[i]]) && nchar(deparse(dots[[i]])[[1]]) < 20
    ) deparse(dots[[i]])[[1]] else sprintf("%s%d", pre, i)
  dots
}
# Used by the `%$%` pipe operator to find the correct point in the RHS to
# substitute the forwarded argument in

sub_dat <- function(z, dat) {
  if(is.call(z)) {
    if(z[[1]] == as.name('%$%')) z[[2]] <- sub_dat(z[[2]], dat)
    else {
      z.list <- as.list(z)
      z <- as.call(c(z.list[1], list(dat), tail(z.list, -1)))
  } }
  z
}
# convert the ".GRP" attribute into usable form

make_grps <- function(x)
  if(is.null(attr(x, ".GRP")) || !length(attr(x, ".GRP")))
    list(rep_len(1, nrow(x))) else attr(x, ".GRP")

# Takes result list and makes into a data.frame by recycling elements so they
# are the same length a longest, and also adds in cols for the group vars

list_to_df <- function(dat, grp) {
  lens <- do.call(pmax, lapply(dat, lengths, integer(length(splits))))
  as.data.frame(
    lapply(c(grp, dat), function(x) unname(unlist(Map(rep_len, x, lens))))
  )
}
```

Our functions behave similar to the `dplyr` functions they copy:

```{r}
state.data %$%
  filter_r(Region %in% c('Northeast', 'South')) %$%
  group_r(Region) %$%
  summarize_r(weighted.mean(Income, Population))
```

But we can store and combine expressions with `quote`:

```{r}
f.exp <- quote(Region %in% c('Northeast', 'South'))
s.exp <- quote(weighted.mean(Income, Population))

state.data %$%
  filter_r(f.exp & Population > 1000) %$%
  group_r(Region) %$%
  summarize_r(round(s.exp))
```

And since `%$%` supports recursive substitutions we can even do the following:

```{r}
flt <- quote(filter_r(f.exp & Population > 1000))
grp.and.sum <- quote(group_r(Region) %$% summarize_r(round(s.exp)))

state.data %$% flt %$% grp.and.sum
```

## Ersatz `data.table`

For those of you unsettled by the pipe, we re-use our previous functions in a
`data.table`-like manner.  This exercise is a demonstration of forwarding NSE
parameters to NSE functions.

Please note that we are taking many liberties here with our method
implementation for the sake of conciseness.

```{r}
as.super_df <- function(x) {
  class(x) <- c("super_df", class(x))
  x
}
"[.super_df" <- function(x, i=NULL, j=NULL, by=NULL) {
  frm <- parent.frame() # as per docs, safer to do this here
  x <- as.data.frame(x)
  x <- eval(bquote(.(filter_r)(     .(x),  .(substitute(i)))), frm)
  x <- eval(bquote(.(group_r_l)(    .(x), .(substitute(by)))), frm)
  x <- eval(bquote(.(summarize_r_l)(.(x),  .(substitute(j)))), frm)
  as.super_df(x)
}
```

The implementation is not trivial, but also not excessively complicated.  Yet
with it we spawn a functional `data.table` simulacra from a `dplyr` one:

```{r}
sd <- as.super_df(state.data)
sd[f.exp, s.exp, by=Region]

exp.a <- quote(max(Illiteracy))
exp.b <- quote(min(Illiteracy))

sd[f.exp, list(exp.a, exp.b), by=list(Region, has_nfl)][1:2,]

exp.c <- quote(list(exp.a, exp.b))
exp.d <- quote(list(Region, has_nfl))

sd[f.exp, exp.c, by=exp.d][1:2,]

```

If done correctly symbols should resolve as expected, even in more complex
circumstances:

```{r}
exps <- quote(list(stop("boo"), stop("ya")))  # don't use this
g.exp <- quote(State)                         # nor this

local({
  summarize_r_l <- function(x, y) stop("boom")  # nor this
  max.inc <- quote(max(Income))                 # use this
  min.inc <- quote(min(Income))                 # and this
  exps <- list(max.inc, min.inc)

  g.exp <- quote(Region)                        # and this

  lapply(exps, function(y) sd[f.exp, y, by=g.exp])
})
```

## Appendix

```{r dplyr_extra, eval=FALSE}
```

## References

[userR2017 Tidyeval Presentation][1]
[Tidyeval and Hygienic Fexprs][2]

[1]: https://schd.ws/hosted_files/user2017/43/tidyeval-user.pdf
[2]: https://www.r-project.org/dsc/2017/slides/tidyeval-hygienic-fexprs.pdf

