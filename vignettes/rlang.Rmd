---
title: "Comparison of Programmable NSE Frameworks"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{vetr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, comment=NA)
library(dplyr)
library(recsub)
```

## Overview

We want to re-implement `summarize_by` function introduced in the [userR 2017
Tidy Eval][1] session:

```{r}
summarise_by <- function(df, group, var) {
  group <- enquo(group)
  var <- enquo(var)
  df %>%
    group_by(!! group) %>%
    summarise(avg = mean(!! var))
}
summarise_by(starwars, species, height) %>% head(2)
```

With `recsub` we would use:

```{r}
summarise_by_r <- function(df, group, var) {
  group <- substitute(group)
  var <- substitute(var)
  expr <- recsub(
    bquote(
      .(df) %>%
      group_by(.(group)) %>%
      summarise(avg = mean(.(var)))
    ),
    df, parent.frame()
  )
  eval(expr, parent.frame())
}
summarise_by_r(starwars, species, height) %>% head(2)
```

While this looks a lot more complicated, keep in mind we just added programmable
NSE to something that has no idea `recsub` even exists.  `dplyr` implements its
own NSE with internal logic to handle the quo/dequo business.

With one advantage that we can do things like:

```{r}
my.var <- quote(species)
summarise_by_r(starwars, my.var, height) %>% head(2)
summarise_by(starwars, my.var, height) %>% head(2)
```

This would be even simpler if `group_by` and `summarise` had been built with
`recsub` to begin with:

```{r}
group_by_r <- function(.data, ..., add=FALSE) {
  group.call <- recsub(sys.call(), .data, parent.frame())
  group.call[[1]] <- quote(group_by)
  eval(group.call, parent.frame())
}
summarise_r <- function(.data, ..., add=FALSE) {
  summarise.call <- recsub(sys.call(), .data, parent.frame())
  summarise.call[[1]] <- quote(summarise)
  eval(summarise.call, parent.frame())
}
summarise_by_r2 <- function(df, group, var) {
  group <- substitute(group)
  var <- substitute(var)
  eval(
    bquote(.(df) %>% group_by_r(.(group)) %>% summarise_r(avg=mean(.(var)))),
    parent.frame()
  )
}
summarise_by_r2(starwars, species, height) %>% head(2)
summarise_by_r2(starwars, my.var, height) %>% head(2)

local({
  my.var <- quote(skin_color)
  summarise_by_r2(starwars, my.var, height) %>% head(2)
})
my.var <- quote(skin_color)
summarise_by_r2(starwars, my.var, height) %>% head(2)
```


```{r}
dot_list <- function(x, pre="V") {
  dots <- tail(as.list(x), -1L)
  # handle case where dots were passed as a list, though ambiguity remains as to
  # whether dots was a single list item...; blergh, how do we resolve?
  if(
    length(dots) == 1L && is.call(dots[[1L]]) &&
    dots[[1L]][[1L]] == quote(list)
  )
    dots <- tail(as.list(dots[[1L]]), -1L)
  for(i in seq_along(dots))
    names(dots)[i] <- if(is.language(dots[[i]])) deparse(dots[[i]])[[1]]
      else sprintf("%s%d", pre, i)
  dots
}
grp_by <- function(.data, ..., .ENV=parent.frame()) {
  grp.sub <- recsub(substitute(list(...)), .data, .ENV)
  structure(.data, .GRP=dot_list(grp.sub, "G"))
}
summr_l <- function(.data, els, .ENV=parent.frame()) {
  exps.sub <- substitute(els)

  # compute groups and split data

  has.grp <- !is.null(attr(.data, ".GRP"))
  .data <- as.data.frame(.data)
  grps <- if(!has.grp) list(rep_len(1, nrow(.data))) else attr(.data, ".GRP")
  splits <- lapply(grps, eval, .data, .ENV)
  dat.split <- split(.data, splits, drop=TRUE)
  grp.split <- if(has.grp) lapply(splits, split, splits, drop=TRUE)

  # compute the aggregations

  res.list <- lapply(
    dot_list(exps.sub),
    function(exp) lapply(dat.split, eval, expr=exp, enclos=.ENV)
  )
  # Find max number of rows in each group, and recycle to that

  lens <- do.call(pmax, lapply(res.list, lengths, integer(length(splits))))
  res.list.r <- lapply(
    c(grp.split, res.list), function(x) unname(unlist(Map(rep_len, x, lens)))
  )
  as.data.frame(res.list.r)

}
```
need a function that will look at a substituted expression and decide whether
it needs to be wrapped in a list.  Some questions:

* how can we tell if it is a list or not?  Do we force it? But maybe it can't
  even be `evaled` under SE?
* Maybe rule is you must explicitly use `list`?  But if you do that, you can
  no longer pass a list as an argument?
* What about if we `recsub`, and check for `list`?  If we want an actual list we
  can just do `list(list())`
* I think in this case, the only issue is that if someone interjects and object
  `list` in the search path that isn't actually the list function, in which case
  we would get confused.  Would have to check that the found object on search
  path is the list we care about; I guess can just run a separate search for
  `list` to confirm.


```{r}
summr <- function(.data, ..., .ENV=parent.env()) {
  exps.sub <- recsub(substitute(list(...)), .data, .ENV)
  eval(.bquote(.(summr_l)(.(.data), .(exps.sub), .ENV)))
}
`[.super_df` <- function(x, i, j, by, drop=FALSE, .ENV=parent.frame()) {
  j.sub <- substitute(j)
  by.sub <- substitute(by)
  eval(bquote(.(summr_l)(.(grp_by)(.(x), .(by.sub)), .(j.sub))), enclos=.ENV)
}
listify <- function(x, envir, enclos) {
  get_with_env("list", as.environment(envir
  if(
    !is.call(x) || (is.call(x) && 
}
`[.super_df` <- function(x, i, j, by, drop=FALSE, .ENV=parent.frame()) {
  j.sub <- listify(recsub(substitute(j), x, .ENV))
  by.sub <- listify(recsub(substitute(by), x, .ENV))




  eval(bquote(.(summr)(.(grp_by)(.(x), .(by.sub)), .(j.sub))), enclos=.ENV)
}

as.super_df <- function(x) {
  class(x) <- c("super_df", class(x))
  x
}
sw <- as.super_df(starwars)
sw[, list(mean(height), max(mass)), list(species, hair_color)]
sw[, mean(height), species]

starwars %>% group_by(species, hair_color) %>% summarize(mean(height))

starwars %>%
  grp_by(species, hair_color) %>%

  summr(median(height), mean(mass))

iris %>% grp_by(Species) %>% summr(sum(Sepal.Length), mean(Sepal.Length))

local({
  my.grp <- quote(Species)
  my.val <- quote(Sepal.Width)
  iris %>% grp_by(my.grp) %>% summr(sum(my.val), mean(my.val))
})

my_sum <- function(.data, group, var) {
  eval(
    bquote(
      .(.data) %>%
        grp_by(.(substitute(group))) %>%
        summr(sum(.(substitute(var))), mean(.(substitute(var))))
    ),
    parent.frame()
  )
}
my_sum(iris, Species, Petal.Length)

```{r}
ll <- base::list
tf <- function(data, ...) {
  expr <- substitute(ll(...))
  vals <- eval(expr, data, parent.frame())
  vals
}
```


## References

[1]: https://schd.ws/hosted_files/user2017/43/tidyeval-user.pdf
[2]: https://www.r-project.org/dsc/2017/slides/tidyeval-hygienic-fexprs.pdf
