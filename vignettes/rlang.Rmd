---
title: "Comparison of Programmable NSE Frameworks"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{vetr}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(error=TRUE, comment=NA)
library(dplyr)
library(recsub)
```

## `recsub` in Action

We will implement simplified versions of `dplyr` and `data.table` to illustrate
how one could use `recsub` to develop programmable NSE functions.  The
implementations will be limited in functionality, robustness, and speed, but
despite this we hope you will find them adequate for pedagogical purposes.

Our test data is derived from the `state` data that comes pre-loaded with R:

```{r}
head(state.data, 2)
```

## An Ersatz `dplyr`

The interface is as follows:

```{r, eval=FALSE}
group_r <- function(x, ...) {...}     # similar to dplyr::group_by
filter_r <- function(x, subset) {...} # similar to dplyr::filter
summarize_r <- function(x, ...) {...} # similar to dplyr::summarise
`%$%` <- function(x, y) {...}         # similar to the magrittr pipe
```

`filter_r` and `group_r` are relatively simple, so we will focus on the
implementation of `summarize_r`.  For the other functions see the appendix.

```{r}
summarize_r <- function(x, ...)
  eval(bquote(.(summarize_r_l)(.(x), .(substitute(list(...))))), parent.frame())
```

`summarize_r` just forwards arguments to `summarize_r_l`.  Notice how we use
`bquote(.(summarize_r_l), ...)` so that `summarize_r_l` is evaluated in the
function frame.  This ensures the symbol resolves in the environment chain of
the function (e.g. in the package namespace if there was one).  The dots instead
are evaluated in the parent frame.

Here is `summarize_r_l`, mostly for reference.  We will highlight the
interesting parts shortly so feel free to skip:

```{r dplyr_extra, echo=FALSE}
# == Grouping ===
group_r <- function(x, ...)
  eval(bquote(.(group_r_l)(.(x), .(substitute(list(...))))), parent.frame())
group_r_l <- function(x, els) {
  exps.sub <- recsub(substitute(els), x, parent.frame())
  if(!is.call(exps.sub) || exps.sub[[1L]] != quote(list))
    exps.sub <- call("list", exps.sub)
  structure(x, .GRP=dot_list(exps.sub, "G"))
}
# == Filtering ==
filter_r <- function(x, subset) {
  sub.exp <- substitute(subset)
  sub.val <- evalr(sub.exp, envir=x, enclos=parent.frame())
  if(!is.null(sub.val))
    as.data.frame(x)[!is.na(sub.val) & sub.val, ] else x
}
# == Pipe ==
`%$%` <- function(x, y) {
  x.sub <- recsub(substitute(x), parent.frame())
  y.sub <- recsub(substitute(y), parent.frame())
  y.list <- if(!is.call(y.sub)) list(y.sub) else as.list(y.sub)
  eval(sub_dat(y.sub, x), parent.frame())
}
# == Helper Funs ==
dot_list <- function(x, pre="V") {
  dots <- tail(as.list(x), -1L)
  if(is.null(names(dots))) names(dots) <- character(length(dots))
  for(i in seq_along(dots)[!nzchar(names(dots))])
    names(dots)[i] <- if(
      is.language(dots[[i]]) && nchar(deparse(dots[[i]])[[1]]) < 15
    ) deparse(dots[[i]])[[1]] else sprintf("%s%d", pre, i)
  dots
}
sub_dat <- function(z, dat) {
  if(is.call(z)) {
    if(z[[1]] == as.name('%$%')) z[[2]] <- sub_dat(z[[2]], dat)
    else {
      z.list <- as.list(z)
      z <- as.call(c(z.list[1], list(dat), tail(z.list, -1)))
  } }
  z
}
```
```{r}
summarize_r_l <- function(x, els) {
  frm <- parent.frame()
  # Handle case where passed as a list or single exp
  exps.sub <- recsub(substitute(els), x, frm)
  if(!is.call(exps.sub) || exps.sub[[1L]] != quote(list))
    exps.sub <- call("list", exps.sub)

  # compute groups and splits
  has.grp <- !is.null(attr(x, ".GRP")) && length(attr(x, ".GRP"))
  x <- as.data.frame(x)
  grps <- if(!has.grp) list(rep_len(1, nrow(x))) else attr(x, ".GRP")
  splits <- lapply(grps, eval, x, frm)
  dat.split <- split(x, splits, drop=TRUE)
  grp.split <- if(has.grp) lapply(splits, split, splits, drop=TRUE)

  # compute the aggregations
  res.list <- lapply(
    dot_list(exps.sub),       # clean up fun, see appendix for def'n
    function(exp) lapply(dat.split, eval, expr=exp, enclos=frm)
  )
  # Find max number of rows in each group, and recycle to that
  lens <- do.call(pmax, lapply(res.list, lengths, integer(length(splits))))
  res.list.r <- lapply(
    c(grp.split, res.list), function(x) unname(unlist(Map(rep_len, x, lens)))
  )
  as.data.frame(res.list.r)
}
```

The only `recsub` specific line is the second one:

```{r, eval=FALSE}
  exps.sub <- recsub(substitute(els), x, frm)
```

This recursively expands the expression in a form that can be correctly
evaluated in the parent frame, which we do on line ~15:

```{r, eval=FALSE}
  res.list <- lapply(
    dot_list(exps.sub),       # clean up fun, see appendix for def'n
    function(exp) lapply(dat.split, eval, expr=exp, enclos=frm)
  )
```

And now for the fun:

```{r}
state.data %$%
  filter_r(Region %in% c('Northeast', 'South')) %$%
  group_r(Region) %$%
  summarize_r(weighted.mean(Income, Population))
```

We can store and combine expressions:

```{r}
f.exp <- quote(Region %in% c('Northeast', 'South'))
s.exp <- quote(weighted.mean(Income, Population))

state.data %$%
  filter_r(f.exp & Population > 1000) %$%
  group_r(Region) %$%
  summarize_r(round(s.exp))
```

And since `%$%` supports recursive substitutions we can even do the following:

```{r}
flt <- quote(filter_r(f.exp & Population > 1000))
grp.and.sum <- quote(group_r(Region) %$% summarize_r(round(s.exp)))

state.data %$% flt %$% grp.and.sum
```

The main advantage of `recusb` is you only need to quote.  The unquoting is
handled at evaluation.

## Ersatz `data.table`

For those of you unsettled by the pipe, we re-use our previous functions in a
`data.table`-like manner:

```{r}
"[.super_df" <- function(x, i, j, by, drop=FALSE) {
  frm <- parent.frame()
  i.sub <- substitute(i)
  j.sub <- substitute(j)
  by.sub <- substitute(by)
  res.df <- eval(
    bquote(
      .(summarize_r_l)(
        .(group_r_l)(
          .(filter_r)(.(x), .(if(!missing(i.sub)) i.sub)),
          .(if(!missing(by.sub)) by.sub else quote(list()))
        ),
        .(if(!missing(j.sub)) j.sub else quote(list()))
    ) ),
    frm
  )
  as.super_df(res.df)
}
as.super_df <- function(x) {
  class(x) <- c("super_df", class(x))
  x
}
```
All we are doing is ensuring that the data and the functions are evaluated in
the frame of `[.super_df`, and the substituted expressions in the parent frame.

```{r}
sd <- as.super_df(state.data)
sd[f.exp, s.exp, by=Region]

```

## Appendix

### Ersatz `dplyr` Functions

```{r dplyr_extra, eval=FALSE}
```

###


```
summ_by <- quote(group_by_r(group) %$% summarize_r(var))
group <- quote(group_r(species))
var <- quote(summarize_r(mean(height)))
group_var <- quote(group %$% var)

starwars %$% group_var
```

We want to re-implement `summarize_by` function introduced in the [userR 2017
Tidy Eval][1] session:

```
summarise_by <- function(df, group, var) {
  group <- enquo(group)
  var <- enquo(var)
  df %>%
    group_by(!! group) %>%
    summarise(avg = mean(!! var))
}
summarise_by(starwars, species, height) %>% head(2)
```

With `recsub` we would use:

```
summarise_by_r <- function(df, group, var) {
  group <- substitute(group)
  var <- substitute(var)
  expr <- recsub(
    bquote(
      .(df) %>%
      group_by(.(group)) %>%
      summarise(avg = mean(.(var)))
    ),
    df, parent.frame()
  )
  eval(expr, parent.frame())
}
summarise_by_r(starwars, species, height) %>% head(2)
```

While this looks a lot more complicated, keep in mind we just added programmable
NSE to something that has no idea `recsub` even exists.  `dplyr` implements its
own NSE with internal logic to handle the quo/dequo business.

With one advantage that we can do things like:

```
my.var <- quote(species)
summarise_by_r(starwars, my.var, height) %>% head(2)
summarise_by(starwars, my.var, height) %>% head(2)
```

This would be even simpler if `group_by` and `summarise` had been built with
`recsub` to begin with:

```
group_by_r <- function(.data, ..., add=FALSE) {
  group.call <- recsub(sys.call(), .data, parent.frame())
  group.call[[1]] <- quote(group_by)
  eval(group.call, parent.frame())
}
summarise_r <- function(.data, ..., add=FALSE) {
  summarise.call <- recsub(sys.call(), .data, parent.frame())
  summarise.call[[1]] <- quote(summarise)
  eval(summarise.call, parent.frame())
}
summarise_by_r2 <- function(df, group, var) {
  group <- substitute(group)
  var <- substitute(var)
  eval(
    bquote(.(df) %>% group_by_r(.(group)) %>% summarise_r(avg=mean(.(var)))),
    parent.frame()
  )
}
summarise_by_r2(starwars, species, height) %>% head(2)
summarise_by_r2(starwars, my.var, height) %>% head(2)

local({
  my.var <- quote(skin_color)
  summarise_by_r2(starwars, my.var, height) %>% head(2)
})
my.var <- quote(skin_color)
summarise_by_r2(starwars, my.var, height) %>% head(2)
```

```

summ_by <- function(x, group, var) {
  eval(
    bquote(
      .(summarize_r_l)(
        .(group_r_l)(.(x), .(substitute(group))),
        mean(.(substitute(var)))
    ) ),
    parent.frame()
  )
}

local({
  a <- 'A'
  b <- 'B'
  y()
})
starwars %$%
  filter_r(!is.na(hair_color)) %$%
  group_r(species, hair_color) %$%
  summarize_r(median(height), mean(mass))

sw <- as.super_df(starwars)
sw[, list(mean(height), max(mass)), list(species, hair_color)]

my.j <- quote(list(mean(height), max(mass)))
sw[, my.j, list(species, hair_color)]

sw[, mean(height), species]
sw[, mean(height, na.rm=T)]

my.grp.var <- quote(species)

var <- NA
local({
  hello <- "hello"
  var <- quote(height)
  e1 <- quote(max(var))
  e2 <- quote(min(var))
  exps <- list(quote(mean(var) / e1), quote(mean(var) / e2))
  lapply(exps, function(x) sw[!is.na(var), x])
})
my_sum <- function(.data, group, var) {
  eval(
    bquote(
      .(.data) %>%
        grp_by(.(substitute(group))) %>%
        summr(sum(.(substitute(var))), mean(.(substitute(var))))
    ),
    parent.frame()
  )
}
my_sum(iris, Species, Petal.Length)

ll <- base::list
tf <- function(data, ...) {
  expr <- substitute(ll(...))
  vals <- eval(expr, data, parent.frame())
  vals
}
```


## References

[1]: https://schd.ws/hosted_files/user2017/43/tidyeval-user.pdf
[2]: https://www.r-project.org/dsc/2017/slides/tidyeval-hygienic-fexprs.pdf
