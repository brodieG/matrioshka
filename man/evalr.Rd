% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval.R
\name{evalr}
\alias{evalr}
\alias{evalqr}
\title{Evaluate Expression After Recursively Substituting It}
\usage{
evalr(expr, envir = parent.frame(), enclos = if (is.list(envir) ||
  is.pairlist(envir)) parent.frame() else baseenv())

evalqr(expr, envir = parent.frame(), enclos = if (is.list(envir) ||
  is.pairlist(envir)) parent.frame() else baseenv())
}
\arguments{
\item{expr}{an object to be evaluated, typically a quoted language object as
returned by \code{quote} or \code{substitute}.  \code{expr} will be recursively
substituted by \code{recsub}.}

\item{envir}{the \code{\link{environment}} in which \code{expr} is to
    be evaluated.  May also be \code{NULL}, a list, a data frame,
    a pairlist or an integer as specified to \code{\link{sys.call}}.}

\item{enclos}{Relevant when \code{envir} is a (pair)list or a data frame.
    Specifies the enclosure, i.e., where \R looks for objects not found
    in \code{envir}.  This can be \code{NULL} (interpreted as the base
    package environment, \code{\link{baseenv}()}) or an environment.}
}
\value{
The result of evaluating the object: for an expression vector this is
the result of evaluating the last element.
}
\description{
Calls \link{recsub} on the inputs, and then evaluates the result with \link{eval}.
This allows us to implement programmable NSE in functions.  \code{evalqr}
substitutes the expression before calling \link{recsub} and evaluating it, similar
to \link{evalq}.
}
\examples{
xzw <- 8:10
aaa <- quote(xzw > 5)
bbb <- quote(xzw < 10)

evalr(quote(xzw[aaa & bbb]))
evalqr(xzw[aaa & bbb])

## Add an interceding frame; here we want to ensure that the
## variable used is the one in the data.frame, not the one we
## just defined above.
DF <- data.frame(xzw=5:7, yac=letters[1:3], stringsAsFactors=FALSE)
DF$xzw    # use this one
xzw       # not this one
evalqr(DF[aaa & bbb, ,drop=FALSE])            # incorrect
evalqr(DF[aaa & bbb, ,drop=FALSE], envir=DF)  # correct

## Implement programmable NSE in a function; use `substitute` to capture
## input unevaluated
subset2 <- function(x, subset) {
  sub.val <- evalr(substitute(subset), envir=x, enclos=parent.frame())
  x[!is.na(sub.val) & sub.val, ]
}
subset2(DF, aaa & yac < 'c')

## Use `recsub` to see the expanded expression:
recsub(quote(aaa & yac < 'c'), envir=DF)
}
\seealso{
\link{eval}, \link{recsub}, \code{vignette('recsub', 'recsub')}
}
