% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expand.R
\name{expand}
\alias{expand}
\title{Recursively Expand Symbols in Quoted Language}
\usage{
expand(expr, envir = parent.frame(), enclos = if (is.list(envir) ||
  is.pairlist(envir)) parent.frame() else baseenv(), shield = TRUE)
}
\arguments{
\item{expr}{an object to be evaluated.  See \sQuote{Details}.}

\item{envir}{the \code{\link{environment}} in which \code{expr} is to
    be evaluated.  May also be \code{NULL}, a list, a data frame,
    a pairlist or an integer as specified to \code{\link{sys.call}}.}

\item{enclos}{Relevant when \code{envir} is a (pair)list or a data frame.
    Specifies the enclosure, i.e., where \R looks for objects not found
    in \code{envir}.  This can be \code{NULL} (interpreted as the base
    package environment, \code{\link{baseenv}()}) or an environment.}

\item{shield}{TRUE, FALSE, or character, determines what portions of quoted
language are shielded from expansion.  TRUE, the default, means that any
any classed language (e.g. formula) will be left unexpanded.  If FALSE all
language will be expanded, irrespective of class.  If character, then any
classed objects with classes in the vector will be left unexpanded, and all
others will be expanded.}
}
\value{
If the input is a language object, that object with all symbols
recursively expanded, otherwise the input unchanged.
}
\description{
Finds symbols in quoted R language objects and recursively replaces them with
any language objects that those symbols point to.  This leads to an expanded
language object that can be evaluated.  Language objects are objects of type
"symbol", "language", or "expression", though only unclassed language
is expanded by default.
}
\section{Programmable NSE}{


The expansion can be used to implement programmable Non-Standard Evaluation
(NSE hereafter).  Users can create complex quoted language expressions from
simple ones by combining them as they would tokens in standard R expressions.
Then, a programmable NSE aware function can use \code{expand} to turn the quoted
language into usable form.  See examples.
}

\section{Expansion mechanics}{


During the recursive expansion, symbols are looked up through the search
path in the same way as standard R evaluation looks up symbols.  One subtlety
is that if symbol A expands to a language object B, the symbols in
language object B are looked for starting from the environment that A is
bound to, not the initial evaluation environment.  Expansion stops at symbols
that point to non-language objects.

Symbols at the first position in calls (e.g. \code{fun} in \code{fun(x, y)}) are
expanded slightly differently: they will continue to be expanded until an
object of mode "function" is found.  This is to follow the semantics of
symbol searches in R where a symbol pointing to a non-function object will
not mask a symbol pointing to a function object when it is used as the name
of the function in a call.

You can prevent expansion of portions of language by giving that language a
class since the default behavior is to keep classed language unexpanded.
This is why formulas are not expanded by default.  Be careful though that you
do not give a symbol a class as that is bad practice and will become an R
runtime error in the future.  See the \code{shield} parameter and examples.

See examples and \code{browseVignettes('oshka')} for more details.
}

\examples{
xzw <- uvt <- NULL  # make sure not lang objects
aaa <- quote(xzw > 3)
bbb <- quote(xzw < 10)
ccc <- quote(aaa & bbb)
expand(ccc)

## You can place list like objects in the search path
l <- list(bbb=quote(uvt < 9999))
expand(ccc, l)

## But notice what happens if we use `quote(ccc)` instead of
## just `ccc`.  This is because in this case `expand` must
## look for the `ccc` symbol in the search path, and once
## it finds it it looks for `aaa` and `bbb` starting from the
## environment `ccc` is bound to, so the `bbb` defined
## inside `l` is skipped.
expand(quote(ccc), l)

## Implementing an NSE fun (see vignettes for detailed
## examples)
subset2 <- function(x, subset) {
  subset <- expand(substitute(subset), x, parent.frame())
  eval(bquote(base::subset(.(x), .(subset))), parent.frame())
}
subset2(iris, Sepal.Width > 4.3)
iris.sub <- quote(Sepal.Width > 4.3)
subset2(iris, iris.sub)

## Shielding
expand(I(ccc))  # add the `AsIs` class to `ccc` with `I`
expand(ccc)

## Notice extra set of parentheses we use around
## `quote((bbb))` as otherwise we would attach attributes
## to a symbol:
ccd <- bquote(aaa & .(I(quote((bbb)))))
expand(ccd)

## Equivalently
cce <- ccc
cce[[3]] <- I(quote((bbb)))
expand(cce)

## Formulas not expanded by default, but can be forced
## to expand by setting `shield` to FALSE
expand(aaa ~ bbb)
expand(aaa ~ bbb, shield=FALSE)
}
