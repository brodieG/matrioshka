% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expand.R
\name{expand}
\alias{expand}
\title{Recursively Expand Symbols in Quoted Language}
\usage{
expand(expr, envir = parent.frame(), enclos = if (is.list(envir) ||
  is.pairlist(envir)) parent.frame() else baseenv(), what = "all")
}
\arguments{
\item{expr}{an object to be evaluated.  See \sQuote{Details}.}

\item{envir}{the \code{\link{environment}} in which \code{expr} is to
    be evaluated.  May also be \code{NULL}, a list, a data frame,
    a pairlist or an integer as specified to \code{\link{sys.call}}.}

\item{enclos}{Relevant when \code{envir} is a (pair)list or a data frame.
    Specifies the enclosure, i.e., where \R looks for objects not found
    in \code{envir}.  This can be \code{NULL} (interpreted as the base
    package environment, \code{\link{baseenv}()}) or an environment.}
}
\value{
If the input is a language object, that object with all symbols
recursively substituted, otherwise the input unchanged.
}
\description{
Finds symbols in quoted R language objects and recursively replaces them with
any language objects that those symbols point to.  This leads to an expanded
language object that can be evaluated.  Language objects are objects of type
"symbol", "language", or "expression".
}
\details{
The expansion can be used to implement programmable Non-Standard Evaluation
(NSE hereafter).  Users can create complex quoted language expressions from
simple ones by combining them as they would tokens in standard R expressions.
Then, a programmable NSE aware function can use \code{expand} to turn the quoted
language into usable form.

During the recursive expansion, symbols are looked up through the search
path in the same way as standard R evaluation looks up symbols.  One subtlety
is that if symbol A expands to a language object B, the symbols in
language object B are looked for starting from the environment that A is
bound to, not the initial evaluation environment.  Expansion stops at symbols
that point to non-language objects.

Symbols at the first position in calls (e.g. \code{fun} in \code{fun(x, y)}) are
expanded slightly differently: they will continue to be expanded until an
object of mode "function" is found.  This is to follow the semantics of
symbol searches in R where a symbol pointing to a non-function object will
not mask a symbol pointing to a function object when it is used as the name
of the function in a call.

See examples and \code{browseVignettes('oshka')} for more details.
}
\examples{
xzw <- uvt <- NULL  # make sure not lang objects
aaa <- quote(xzw > 3)
bbb <- quote(xzw < 10)
ccc <- quote(aaa & bbb)
expand(ccc)

## You can place list like objects in the search path
l <- list(bbb=quote(uvt < 9999))
expand(ccc, l)

## But notice what happens if we use `quote(ccc)` instead of
## just `ccc`.  This is because in this case `expand` must
## look for the `ccc` symbol in the search path, and once
## it finds it it looks for `aaa` and `bbb` starting from the
## environment `ccc` is bound to, so the `bbb` defined
## inside `l` is skipped.
expand(quote(ccc), l)

## Implementing an NSE fun (see vignettes for detailed
## examples)
subset2 <- function(x, subset) {
  subset <- expand(substitute(subset), x, parent.frame())
  eval(bquote(base::subset(.(x), .(subset))), parent.frame())
}
subset2(iris, Sepal.Width > 4.3)
iris.sub <- quote(Sepal.Width > 4.3)
subset2(iris, iris.sub)
}
